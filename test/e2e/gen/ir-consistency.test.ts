import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import * as fs from 'node:fs'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
import * as yaml from 'js-yaml'
import { parseOpenAPIFile } from '../../../src/lib/openapi-parser'
import { runCommand } from './cli-helper'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const fixturesDir = path.join(__dirname, '../fixtures')
const mitseinInputDir = path.join(fixturesDir, 'mitsein', 'input')
const projectRoot = path.resolve(__dirname, '../../../')

// Read IR from file (generated by ir command)
async function readIRFromFile(filePath: string): Promise<any> {
  const content = fs.readFileSync(filePath, 'utf-8')
  if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
    return yaml.load(content)
  } else {
    return JSON.parse(content)
  }
}

/**
 * Normalize IR for comparison (remove order-dependent differences)
 */
function normalizeIR(ir: any): any {
  const normalized = JSON.parse(JSON.stringify(ir))

  // Sort paths keys
  if (normalized.paths && typeof normalized.paths === 'object') {
    const sortedPaths: any = {}
    const sortedKeys = Object.keys(normalized.paths).sort()
    for (const key of sortedKeys) {
      sortedPaths[key] = normalized.paths[key]
    }
    normalized.paths = sortedPaths
  }

  // Sort components.schemas keys
  if (normalized.components?.schemas && typeof normalized.components.schemas === 'object') {
    const sortedSchemas: any = {}
    const sortedKeys = Object.keys(normalized.components.schemas).sort()
    for (const key of sortedKeys) {
      sortedSchemas[key] = normalized.components.schemas[key]
    }
    normalized.components.schemas = sortedSchemas
  }

  // Sort components.parameters keys
  if (normalized.components?.parameters && typeof normalized.components.parameters === 'object') {
    const sortedParams: any = {}
    const sortedKeys = Object.keys(normalized.components.parameters).sort()
    for (const key of sortedKeys) {
      sortedParams[key] = normalized.components.parameters[key]
    }
    normalized.components.parameters = sortedParams
  }

  // Sort components.responses keys
  if (normalized.components?.responses && typeof normalized.components.responses === 'object') {
    const sortedResponses: any = {}
    const sortedKeys = Object.keys(normalized.components.responses).sort()
    for (const key of sortedKeys) {
      sortedResponses[key] = normalized.components.responses[key]
    }
    normalized.components.responses = sortedResponses
  }

  return normalized
}

/**
 * Deep compare two IR objects
 */
function compareIR(ir1: any, ir2: any, path: string = ''): string[] {
  const differences: string[] = []

  if (ir1 === ir2) {
    return differences
  }

  if (ir1 === null || ir2 === null || ir1 === undefined || ir2 === undefined) {
    differences.push(`${path}: ${JSON.stringify(ir1)} !== ${JSON.stringify(ir2)}`)
    return differences
  }

  if (typeof ir1 !== typeof ir2) {
    differences.push(`${path}: type mismatch (${typeof ir1} !== ${typeof ir2})`)
    return differences
  }

  if (typeof ir1 !== 'object' || Array.isArray(ir1)) {
    if (JSON.stringify(ir1) !== JSON.stringify(ir2)) {
      differences.push(`${path}: ${JSON.stringify(ir1)} !== ${JSON.stringify(ir2)}`)
    }
    return differences
  }

  // Compare objects
  const keys1 = Object.keys(ir1).sort()
  const keys2 = Object.keys(ir2).sort()

  // Check for missing keys
  for (const key of keys1) {
    if (!(key in ir2)) {
      differences.push(`${path}.${key}: missing in ir2`)
    }
  }

  for (const key of keys2) {
    if (!(key in ir1)) {
      differences.push(`${path}.${key}: missing in ir1`)
    }
  }

  // Compare common keys
  for (const key of keys1) {
    if (key in ir2) {
      const newPath = path ? `${path}.${key}` : key
      differences.push(...compareIR(ir1[key], ir2[key], newPath))
    }
  }

  return differences
}

describe('IR Consistency Test - Mitsein', () => {
  let tempOutputDir: string

  beforeAll(() => {
    const tmpTestDir = path.join(projectRoot, '.tmp-test')
    fs.mkdirSync(tmpTestDir, { recursive: true })
    tempOutputDir = fs.mkdtempSync(path.join(tmpTestDir, 'ir-consistency-'))
  })

  afterAll(() => {
    if (tempOutputDir && fs.existsSync(tempOutputDir)) {
      fs.rmSync(tempOutputDir, { recursive: true, force: true })
    }
  })

  describe('All-in-one mode', () => {
    it('should generate IR that matches original definition IR', async () => {
      const originalFile = path.join(mitseinInputDir, 'mitsein.allinone.yaml')
      
      // Step 1: Generate IR from original definition
      console.log(`\nðŸ“„ Step 1: Generating IR from original definition: ${originalFile}`)
      const originalIRPath = path.join(tempOutputDir, 'original-ir.yaml')
      await runCommand('ir', [originalFile], {
        output: originalIRPath,
        format: 'yaml',
      })
      const originalIR = await readIRFromFile(originalIRPath)
      const normalizedOriginalIR = normalizeIR(originalIR)
      console.log(`   âœ… Original IR generated (${Object.keys(normalizedOriginalIR.paths || {}).length} paths, ${Object.keys(normalizedOriginalIR.components?.schemas || {}).length} schemas)`)

      // Step 2: Generate normalized OpenAPI file using gen openapi --allinone
      console.log(`\nðŸ“ Step 2: Generating normalized OpenAPI file using gen openapi --allinone...`)
      const openapiOutputDir = path.join(tempOutputDir, 'openapi-allinone')
      await runCommand('gen openapi', [originalFile], {
        outputDir: openapiOutputDir,
        allinone: 'mitsein',
      })
      const generatedOpenAPIFile = path.join(openapiOutputDir, 'mitsein.oapi.yaml')
      if (!fs.existsSync(generatedOpenAPIFile)) {
        throw new Error(`Generated OpenAPI file not found: ${generatedOpenAPIFile}`)
      }
      console.log(`   âœ… Generated normalized OpenAPI file: ${generatedOpenAPIFile}`)

      // Step 3: Generate IR from the normalized OpenAPI file
      console.log(`\nðŸ”„ Step 3: Generating IR from normalized OpenAPI file...`)
      const generatedIRPath = path.join(tempOutputDir, 'generated-ir.yaml')
      await runCommand('ir', [generatedOpenAPIFile], {
        output: generatedIRPath,
        format: 'yaml',
      })
      const generatedIR = await readIRFromFile(generatedIRPath)
      const normalizedGeneratedIR = normalizeIR(generatedIR)
      console.log(`   âœ… Generated IR from normalized file (${Object.keys(normalizedGeneratedIR.paths || {}).length} paths, ${Object.keys(normalizedGeneratedIR.components?.schemas || {}).length} schemas)`)

      // Step 4: Compare IRs
      console.log(`\nðŸ” Step 4: Comparing IRs...`)
      const differences = compareIR(normalizedOriginalIR, normalizedGeneratedIR)

      if (differences.length > 0) {
        console.error(`\nâŒ Found ${differences.length} differences:`)
        for (const diff of differences.slice(0, 50)) {
          console.error(`  ${diff}`)
        }
        if (differences.length > 50) {
          console.error(`  ... and ${differences.length - 50} more differences`)
        }
        throw new Error(`IRs are not identical. Found ${differences.length} differences.`)
      } else {
        console.log(`   âœ… IRs are identical!`)
      }
    })
  })

  describe('Split mode', () => {
    it('should generate IR that matches original definition IR', async () => {
      const originalFile = path.join(mitseinInputDir, 'mitsein.yaml')
      
      // Step 1: Generate IR from original split definition
      console.log(`\nðŸ“„ Step 1: Generating IR from original split definition: ${originalFile}`)
      const originalIRPath = path.join(tempOutputDir, 'original-split-ir.yaml')
      await runCommand('ir', [originalFile], {
        output: originalIRPath,
        format: 'yaml',
      })
      const originalIR = await readIRFromFile(originalIRPath)
      const normalizedOriginalIR = normalizeIR(originalIR)
      console.log(`   âœ… Original IR generated (${Object.keys(normalizedOriginalIR.paths || {}).length} paths, ${Object.keys(normalizedOriginalIR.components?.schemas || {}).length} schemas)`)

      // Step 2: Generate normalized OpenAPI files (split mode) using gen openapi
      console.log(`\nðŸ“ Step 2: Generating normalized OpenAPI files (split mode) using gen openapi...`)
      const openapiOutputDir = path.join(tempOutputDir, 'openapi-split')
      await runCommand('gen openapi', [originalFile], {
        outputDir: openapiOutputDir,
      })
      console.log(`   âœ… Generated normalized OpenAPI files in split mode`)

      // Step 3: Generate allinone OpenAPI file from split files
      // First, we need to find the main file that references all split files
      // For now, we'll generate allinone from the original split definition
      console.log(`\nðŸ“ Step 3: Generating allinone OpenAPI file from split definition...`)
      const allinoneOutputDir = path.join(tempOutputDir, 'openapi-split-allinone')
      await runCommand('gen openapi', [originalFile], {
        outputDir: allinoneOutputDir,
        allinone: 'mitsein',
      })
      const generatedAllinoneFile = path.join(allinoneOutputDir, 'mitsein.oapi.yaml')
      if (!fs.existsSync(generatedAllinoneFile)) {
        throw new Error(`Generated allinone OpenAPI file not found: ${generatedAllinoneFile}`)
      }
      console.log(`   âœ… Generated allinone OpenAPI file: ${generatedAllinoneFile}`)

      // Step 4: Generate IR from the generated allinone file
      console.log(`\nðŸ”„ Step 4: Generating IR from generated allinone OpenAPI file...`)
      const generatedIRPath = path.join(tempOutputDir, 'generated-split-ir.yaml')
      await runCommand('ir', [generatedAllinoneFile], {
        output: generatedIRPath,
        format: 'yaml',
      })
      const generatedIR = await readIRFromFile(generatedIRPath)
      const normalizedGeneratedIR = normalizeIR(generatedIR)
      console.log(`   âœ… Generated IR from allinone file (${Object.keys(normalizedGeneratedIR.paths || {}).length} paths, ${Object.keys(normalizedGeneratedIR.components?.schemas || {}).length} schemas)`)

      // Step 5: Compare IRs
      console.log(`\nðŸ” Step 5: Comparing IRs...`)
      const differences = compareIR(normalizedOriginalIR, normalizedGeneratedIR)

      if (differences.length > 0) {
        console.error(`\nâŒ Found ${differences.length} differences:`)
        for (const diff of differences.slice(0, 50)) {
          console.error(`  ${diff}`)
        }
        if (differences.length > 50) {
          console.error(`  ... and ${differences.length - 50} more differences`)
        }
        throw new Error(`IRs are not identical. Found ${differences.length} differences.`)
      } else {
        console.log(`   âœ… IRs are identical!`)
      }
    })
  })
})

